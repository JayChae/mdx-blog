# Simple Blockchain

## 블록체인이란?

블록체인이라고 하면 첨단 기술 같지만 그 개념은 간단합니다.
한 줄 로 정리하자면

```
해시값으로 연결된 블록을 쌓아가는 분산형 데이터베이스.
```

블록체인을 이해하기 위해서는 블록, 해시값, 체인, 분산형 데이터베이스가 무엇인지 알아야 합니다.

### 블록

여러 거래(또는 기록)를 일정한 단위로 묶어 놓은 데이터 집합입니다.
블록체인의 블록에는 자신의 해시값과 이전 블록의 해시값을 데이터로 가지고 있습니다.

```ts
class Block {
  public index: number // 인덱스
  public previousHash: string // 이전 블록의 해시 값
  public timestamp: number // 생성 시간
  public data: Transaction[] // 담고 싶은 데이터 (거래 내역)
  public hash: string // 해당 블록의 해시값

  constructor(
    index: number,
    previousHash: string,
    timestamp: number,
    data: Transaction[],
    difficulty: number,
    nonce: number,
    hash: string,
  ) {
    this.index = index
    this.previousHash = previousHash
    this.timestamp = timestamp
    this.data = data
    this.hash = hash
  }
}
```

블록체인에 첫번째로 생성된 블록은 이전 블록이 없겠죠? 그런 블록은 이전 블록의 해시값을 가지고 있지 않습니다. 이런 특별한 블록을 **제네시스 블록**이라고 합니다. 이는 하드 코딩으로 생성해야 합니다.

```ts
const genesisBlock: Block = new Block(
  0,
  '',
  1756716811,
  'Let there be a block',
  '38cdd2a4bdf21856e32e440da4ade0441e5b327f87981fe18dc63c4e1f0a2db6',
)
```

### 해시

데이터를 일정한 길이의 고정된 문자열로 변환하는 암호학적 함수입니다. 해시 함수의 핵심은 4 가지입니다.

#### 1. 일가성 함수

해시 함수도 함수입니다. 입력값이 같으면 항상 동일한 출력값을 냅니다.

#### 2. 고정된 길이 출력

해시 함수에는 어떤 데이터든지 들어갈 수 있습니다. 그러나 입력값에 상관없이 언제나 똑같은 길이의 값을 출력합니다.
simple coin은 비트코인과 같이 SHA256 해시 함수를 사용합니다. 작은 데이터를 넣든, 큰 데이터를 넣든 언제느 16진수(HEX)의 64글자가 결괏값으로 나옵니다.
해시 함수는 고정된 길이를 출력하기 때문에 해싱을 입력값을 압축한 것으로 받아들여도 좋습니다. 즉 대표값으로 여길 수 있습니다. 이 때문에 해싱해서 나온 출력값을 메시지 다이제스트(Message Digest) 또는 지문(fingerprint)라고도 합니다.

#### 3. 눈사태 효과

눈사태 효과란 입력값이 아주 조금만 바꿔도 완전히 다른 결괏값이 나오는 것을 의미합니다.
입력값이 비슷해도 출력값에서는 유사성을 전혀 찾아볼 수 없습니다.

#### 4. 단방향성

해시 함수의 가장 중요한 특징입니다. 출력값을 보고 입력값을 알아낼 수 없습니다. 이 특징 때문에 해시 함수는 보안 분야에서 많이 사용됩니다.

### 체인

블록의 모든 데이터를 해싱한 값을 블록의 해시값으로 사용하고 대표값으로 활용합니다.
각 블록은 이전 블록의 해시값을 포함하고 있기 때문에, 마치 **체인**처럼 끊어지지 않고 연결됩니다.

![블록](https://github.com/user-attachments/assets/e9af0399-2883-4af5-98e6-a65939187d53)

```ts
// index, previousHash, timestamp, data를 해싱
calculateHash(
    index: number,
    previousHash: string,
    timestamp: number,
    data: string
): string => {
    return CryptoJS.SHA256(index + previousHash + timestamp + data).toString();
}


const generateBlock = (blockData: string) => {
  const previousBlock: Block = getLatestBlock(); // 마지막 블록
  const nextIndex: number = previousBlock.index + 1;
  const nextTimestamp: number = new Date().getTime() / 1000;
  const nextHash: string = calculateHash(
    nextIndex,
    previousBlock.hash,
    nextTimestamp,
    blockData
  );
  const newBlock: Block = new Block(
    nextIndex,
    previousBlock.hash,
    nextTimestamp,
    blockData,
    nextHash
  );
  return newBlock;
};

```

블록의 해시값에는 "이전 블록의 해시값"이 들어가기 때문에 두 블록은 완전히 연결됩니다. 해당 해시값이 나오기 위해서는 이전 블록의 데이터를 품고 있을 수 밖에 없습니다.
여기서 선후관계가 만들어지고, 각 블록의 연결 고리가 만들어집니다.

이러한 구조를 가지고 있기 때문에 특정 블록의 데이터를 위조하면 특정 블록 이후에 있는 모든 블록의 값을 변경해야 학디 때문에 위변조가 매우 어려워집니다.

![체인](https://github.com/user-attachments/assets/27be6839-a5ae-4856-8f45-f6fb763b3592)

비트코인을 만든 사토시 나카모토가 이 개념을 처음 백서에서 소개할 때는 블록체인이라는 말을 쓰지 않았지만 블록들이 체인처럼 연결되어 있기 때문에 이 말이 대중화가 되었다고 합니다.

### 분산형 데이터베이스

물리적으로는 여러 위치에 분산되어 있지만, 논리적으로는 하나의 통합된 데이터베이스 시스템처럼 동작하는 데이터베이스를 말합니다. 여러 대의 컴퓨터(노드 또는 인스턴스)가 네트워크를 통해 연결되어 있고, 각각의 컴퓨터가 모두 데이터를 저장하고 처리합니다. 서버를 두고 한 곳에서만 처리하지 않기 때문에 한 곳에서 문제가 생겨도 시스템 전체가 멈추지 않고 계속 돌아갑니다.
즉, 해시로 연결되어 있는 블록 데이터들을 한 곳에 저장한 것이 아니라 여러 컴퓨터가 모두 가지고 있고 네트워크를 통해 서로 계속해서 통신하며 업데이트를 할 때, 블록체인이 완성됩니다.

![블록체인](https://github.com/user-attachments/assets/941afa2b-fc63-4c3a-912f-a897cd0ee0e9)

## 구현

### 블록체인 저장 및 무결성 검증

simple coin은 인메모리 자바스크립트 배열을 사용하여 블록체인을 저장합니다. 노드가 종료되면 데이터가 영구적으로 저장되지 않습니다.

```javascript
const blockchain: Block[] = [genesisBlock];
```

### 무결성 검증

언제든지 블록 또는 블록 체인의 **무결성을 검증**할 수 있어야 합니다.
특히 다른 노드로부터 새로운 블록을 수신했을 때 이를 수락할지 여부를 결정해야 하기 때문에 매우 중요합니다.

### 블록 검증

블록이 유효하려면 다음 조건이 충족되어야 합니다.

- 블록의 **인덱스**는 이전 블록의 인덱스보다 1이 커야 합니다.
- 블록의 `previousHash`는 이전 블록의 `hash`와 일치해야 합니다.
- 블록 자체의 `hash`가 유효해야 합니다.

```ts
const isValidBlock = (newBlock: Block, previousBlock: Block): boolean => {
  if (!isValidBlockStructure(newBlock)) {
    console.log('invalid structure')
    return false
  }

  if (previousBlock.index + 1 !== newBlock.index) {
    console.log('invalid index')
    return false
  }

  if (previousBlock.hash !== newBlock.previousHash) {
    console.log('invalid previousHash')
    return false
  }

  if (calculateHashForBlock(newBlock) !== newBlock.hash) {
    console.log('invalid hash')
    return false
  }
  return true
}
```

### 블록체인 검증

제네시스 블록부터 시작하여 순차적으로 모든 블록이 유효한지 검사합니다.

```ts
const isValidChain = (blockchainToValidate: Block[]): boolean => {
  if (!isValidGenesis(blockchainToValidate[0])) {
    return false
  }

  for (let i = 1; i < blockchainToValidate.length; i++) {
    if (
      !isValidNewBlock(blockchainToValidate[i], blockchainToValidate[i - 1])
    ) {
      return false
    }
  }
  return true
}
```

### 충돌 상황(Fork)

충돌이 발생하는 경우(예: 두 노드가 동시에 블록 번호 72를 생성하는 경우) 블록 수가 가장 긴 체인을 선택합니다.

![fork](https://github.com/user-attachments/assets/10d8c392-2077-462c-b6c6-f389941e6f84)

```ts
const replaceChain = (newBlockchain: Block[]) => {
  if (
    isValidChain(newBlockchain) &&
    newBlockchain.length > getBlockchain().length
  ) {
    console.log(
      'Received blockchain is valid. Replacing current blockchain with received blockchain',
    )
    blockchain = newBlockchain
  } else {
    console.log('Received blockchain invalid')
  }
}
```

## 다음 챕터

다음 챕터에서는 노드를 연결해서 블록체인 네트워크를 만들어 분산형 데이터베이스를 구현해보겠습니다.
