# Simple Proof of Work

작업 증명(Proof of Work)이란 네트워크 참가자가 복잡한 연산 문제(퍼즐)를 풀어야만 새로운 블록을 블록체인에 추가할 수 있게 만드는 것을 의미합니다. 마치 답이 나올 때까지 제비나 복권을 뽑는 걸로 비유할 수 있습니다. 이 퍼즐을 푸는 과정을 보통 "채굴"이라고 합니다.

참고: 이 챕터에서는 아직 트랜잭션을 도입하지 않습니다. 따라서 채굴자에게 블록을 생성할 인센티브가 없습니다. 일반적으로 암호화폐에서는 블록을 찾은 채굴자에게 보상이 주어지지만, 아직 해당 기능이 없지만 차후 챕터에서 도입합니다.

## Why PoW(Proof of Work)

작업증명은 왜 필요할까요?

### 보안 강화

만약 아무 검증 없이 누구나 쉽게 블록을 추가할 수 있다면, 악의적인 사용자가 잘못된 거래를 블록체인에 넣을 수 있습니다. 예를 들어 이미 사용한 돈을 두 번 쓰는(이중지불) 거래를 블록체인에 넣을 수도 있겠죠. 블록을 만들기 위해 막대한 연산 자원(전기·컴퓨터)을 소모해야 하므로, 공격자가 네트워크를 속이려면 엄청난 비용을 지불해야 하기 때문에 공격을 경제적으로 불가능하게 만듭니다.

### 탈중앙화된 합의

검증된 거래 내역을 블록에 담고 블록체인에 추가하는 활동에 아무런 보상이 없다면 아무도 그 활동을 하지 않을 것입니다. 이를 해결하기 위해 블록을 생성했을 때, 보상으로 암호화폐, 예를 들면 비트코인을 받습니다. 보상을 받으려고 블록을 추가하려는 사람이 많아졌을 때, 누가 먼저 블록을 올렸는지 결정하는 시스템이 필요합니다. 하지만 블록체인은 관리자가 없기 때문에 다음 블록이 어떤 블록이 되어야 하는 결정하는 심판이 없습니다. 이에 대한 해결책이 바로 PoW입니다.

PoW는 "어려운 수학 퍼즐을 가장 먼저 푼 사람"이 블록을 추가할 수 있도록 합니다. 또한 충돌 상황, 즉 포크 상황이 되어 블록체인이 한 개 이상으로 분기 되었을 때 PoW는 "가장 많은 연산력이 투입된 블록체인"을 정식 기록으로 인정합니다.이러한 방식은 경쟁을 통한 공정한 선정 방식이라고 할 수 있습니다. 가장 빨리 가장 많이 연산한 블록이 경쟁에서 승리합니다.

### 블록 추가 간격 제어

작업 증명은 퍼즐의 난이도를 조절하여 블록이 블록체인에 추가되는 간격을 (대략적으로) 제어할 수 있게 합니다. 블록이 너무 자주 채굴되면 퍼즐의 난이도가 올라가고, 반대의 경우 난이도가 내려갑니다. 그렇다면 왜 간격을 제어해야 할까요?

#### 네트워크 안정성 유지

블록이 너무 빨리 생성되면 동시에 생성되는 블록이 많아져서 체인 분기(Fork) 자주 발생합니다. 또한 블록이 너무 느리게 생성되면 거래가 블록에 포함되기까지 오래 걸려서 속도/사용성 저하됩니다. 이를 위해 퍼즐의 난이도를 조절해서 네트워크 안정성을 지킬 수 있습니다.

#### 예측 가능한 발행량 유지

비트코인의 경우, 설계 상 약 10분마다 블록 하나가 만들어지도록 되어 있습니다. 이 속도를 맞추면, 전체 발행량(21M BTC 한정)이 예상대로 진행되며 인플레이션 억제할 수 있습니다.

#### 채굴기 성능 발전 대응

시간이 지남에 따라 채굴자는 더 강력한 하드웨어(GPU → ASIC)를 사용합니다. 만약 난이도를 고정해두면, 새로운 장비 등장 시 블록이 순식간에 생성하고 시스템 붕괴될 수 있습니다. 그래서 네트워크는 주기적으로 난이도를 조정해 채굴 속도를 안정화시킵니다.

### 화폐는 무엇으로 생성되어야 바람직한가?

작업증명 방식은 비트코인 철학에서 매우 중요한 의미를 가집니다. 비트코인의 경우 작업증명 방식은 비트코인을 생성하는 유일한 방식입니다. 즉 에너지와 시간을 써야만 비트코인을 만들 수 있습니다. 이는 에너지와 시간이 비트코인으로 바뀌는 거라고 할 수 있습니다. 우주에서 진정으로 희소한 자원은 에너지와 시간뿐이기 때문에 가장 바람직한 화폐 생산 방식이라고 비트코인 지지자들은 이야기 합니다. 시간과 에너지로 코인을 생성할 수 있게 하는 작업증명 방식은 비트코인 철학에 중요한 부분 중에 하나인 것 같습니다.

## 블록 구조

```ts
class Block {
  public index: number
  public hash: string
  public previousHash: string
  public timestamp: number
  public data: Transaction[]
  public difficulty: number
  public nonce: number

  constructor(
    index: number,
    previousHash: string,
    timestamp: number,
    data: Transaction[],
    difficulty: number,
    nonce: number,
    hash: string,
  ) {
    this.index = index
    this.previousHash = previousHash
    this.timestamp = timestamp
    this.data = data
    this.difficulty = difficulty
    this.nonce = nonce
    this.hash = hash
  }
}
```

![](https://media.licdn.com/dms/image/v2/C5612AQGZUKeR_egfrw/article-cover_image-shrink_720_1280/article-cover_image-shrink_720_1280/0/1646509320509?e=1760572800&v=beta&t=CqZSwI7t10IuQdaio5RlvK3dG1aO67Cw2OxYSSaiGsA)

## 난이도

블록 구조에 난이도(difficulty)라는 새로운 속성을 추가합니다. 난이도를 이해하기 위해서는 먼저 작업증명 퍼즐에 대해 알아야 합니다.

작업증명 퍼즐은 특정 개수의 0으로 시작하는 접두사(prefixing zeros)를 가진 블록 해시를 찾는 것입니다. 난이도 속성은 블록 해시가 유효하기 위해 반드시 가져야 하는 접두사 0의 개수를 정의합니다. 이 접두사 0은 해시의 이진 형식(binary format)에서 확인합니다.

다음은 다양한 난이도에 대한 유효한 해시와 유효하지 않은 해시의 예시입니다.

### 난이도 2

- **유효한 해시**: `001a3c7f...`
  - 해시의 이진 형식(binary format)이 2개 이상의 0으로 시작합니다.
- **유효하지 않은 해시**: `01234567...`
  - 해시의 이진 형식이 2개 이상의 0으로 시작하지 않습니다.

### 난이도 3

- **유효한 해시**: `000b1d2e...`
  - 해시의 이진 형식이 3개 이상의 0으로 시작합니다.
- **유효하지 않은 해시**: `001f3g4h...`
  - 해시의 이진 형식이 3개 이상의 0으로 시작하지 않습니다.

```ts
const hashMatchesDifficulty = (hash: string, difficulty: number): boolean => {
  const hashInBinary: string = hexToBinary(hash)
  const requiredPrefix: string = '0'.repeat(difficulty)
  return hashInBinary.startsWith(requiredPrefix)
}
```

난이도가 높아질수록(예: 난이도 2에서 난이도 4로), 유효한 해시를 찾기 위해 필요한 계산량이 기하급수적으로 증가하게 됩니다. 이는 작업증명의 핵심적인 특성 중 하나입니다.

## 논스(nonce)

블록 구조에 난이도(difficulty)라는 새로운 속성을 추가합니다. 채굴자(miner)는 블록 헤더에 있는 '논스' 값을 변경하여 블록 해시를 계속해서 새로 계산합니다. 이 과정을 반복하면서, 채굴자는 현재 난이도에 맞는 선행 0의 개수를 가진 유효한 해시를 찾으려고 시도합니다. 유효한 해시를 찾으면 해당 블록을 채굴했다고 간주하고, 이를 다른 노드에 전파합니다.

```ts
const findBlock = (
  index: number,
  previousHash: string,
  timestamp: number,
  data: Transaction[],
  difficulty: number,
): Block => {
  let nonce = 0
  while (true) {
    const hash: string = calculateHash(
      index,
      previousHash,
      timestamp,
      data,
      difficulty,
      nonce,
    )
    if (hashMatchesDifficulty(hash, difficulty)) {
      return new Block(
        index,
        previousHash,
        timestamp,
        data,
        difficulty,
        nonce,
        hash,
      )
    }
    nonce++
  }
}
```

## 합의 난이도

난이도는 어떻게 결정할까요? 노드들이 현재 난이도에 대해 합의할 수 있는 방법이 있어야 합니다.

새로운 상수를 다음과 같이 정의합니다:

- **BLOCK_GENERATION_INTERVAL**: 블록이 얼마나 자주 발견되어야 하는지를 정의합니다. (비트코인의 경우 이 값은 10분입니다)
- **DIFFICULTY_ADJUSTMENT_INTERVAL**: 증가하거나 감소하는 네트워크의 해시레이트에 맞춰 난이도가 얼마나 자주 조정되어야 하는지를 정의합니다. (비트코인의 경우 이 값은 2016 블록입니다)

우리는 **블록 생성 간격을 10초**로, **난이도 조정 간격을 10블록**으로 설정할 것입니다. 이 상수들은 시간이 지나도 변하지 않고, 하드코딩됩니다.

```ts
// in seconds
const BLOCK_GENERATION_INTERVAL: number = 10

// in blocks
const DIFFICULTY_ADJUSTMENT_INTERVAL: number = 10
```

생성된 10개의 블록마다 해당 블록들을 생성하는 데 걸린 시간이 예상 시간보다 더 길었는지 또는 짧았는지를 확인합니다.예상 시간은 다음과 같이 계산됩니다.

```
BLOCK_GENERATION_INTERVAL X DIFFICULTY_ADJUSTMENT_INTERVAL
```

이 예상 시간은 해시레이트가 현재 난이도와 정확히 일치하는 경우를 나타냅니다.만약 걸린 시간이 예상 시간보다 최소 두 배 이상 길거나 짧으면, 난이도를 1만큼 증가시키거나 감소시킵니다. 난이도 조정은 다음 코드로 처리됩니다:

```ts
const getDifficulty = (aBlockchain: Block[]): number => {
  const latestBlock: Block = aBlockchain[blockchain.length - 1]
  if (
    latestBlock.index % DIFFICULTY_ADJUSTMENT_INTERVAL === 0 &&
    latestBlock.index !== 0
  ) {
    return getAdjustedDifficulty(latestBlock, aBlockchain)
  } else {
    return latestBlock.difficulty
  }
}

const getAdjustedDifficulty = (latestBlock: Block, aBlockchain: Block[]) => {
  const prevAdjustmentBlock: Block =
    aBlockchain[blockchain.length - DIFFICULTY_ADJUSTMENT_INTERVAL]
  const timeExpected: number =
    BLOCK_GENERATION_INTERVAL * DIFFICULTY_ADJUSTMENT_INTERVAL
  const timeTaken: number =
    latestBlock.timestamp - prevAdjustmentBlock.timestamp
  if (timeTaken < timeExpected / 2) {
    return prevAdjustmentBlock.difficulty + 1
  } else if (timeTaken > timeExpected * 2) {
    return prevAdjustmentBlock.difficulty - 1
  } else {
    return prevAdjustmentBlock.difficulty
  }
}
```

### 타임스탬프 유효성 검사 (Timestamp Validation)

지금까지 코드에서는 타임스탬프는 역할이 없었고, 유효성 검사도 이루어지지 않았습니다. 사실 클라이언트가 원하는 대로 생성할 수 있었습니다. 하지만 이제 난이도 조정이 도입되면서 상황이 바뀝니다. 타임스탬프를 조작하여 난이도를 변경하려는 공격이 있을 수 있습니다. 이를 막기 위해 다음과 같은 규칙을 도입합니다:

- 블록의 타임스탬프가 **우리가 인식하는 시간**보다 최대 1분 미래일 경우에만 해당 블록은 유효합니다.
- 블록체인 상의 블록은, 이전 블록의 타임스탬프보다 최대 1분 과거일 경우에만 유효합니다.

```ts
const isValidTimestamp = (newBlock: Block, previousBlock: Block): boolean => {
  return (
    previousBlock.timestamp - 60 < newBlock.timestamp &&
    newBlock.timestamp - 60 < getCurrentTimestamp()
  )
}
```

네, 'Cumulative difficulty' 부분도 번역해 드릴게요.

---

### 누적 난이도 (Cumulative difficulty)

지금까지 블록체인에서는 항상 '가장 긴' 블록체인을 유효한 것으로 선택했습니다. 하지만 이제 작업증명이 도입되었기 때문에 이 규칙은 바뀌어야 합니다. 이제부터 '올바른' 체인은 '가장 긴' 체인이 아니라, '가장 높은 누적 난이도'를 가진 체인입니다. 다시 말해, 올바른 체인은 블록을 생성하는 데 가장 많은 자원(해시레이트 × 시간)이 소모된 체인입니다.

한 체인의 누적 난이도를 구하려면, 각 블록의 난이도를 바탕으로 2^난이도를 계산하여 그 값들을 모두 더합니다. '2^난이도'를 사용하는 이유는 우리가 난이도를 해시의 이진 형식 앞에 붙어야 할 0의 개수로 정했기 때문입니다. 예를 들어, 난이도 5와 11을 비교하면, 후자의 난이도를 가진 블록을 찾는 데는 2^(11-5) = 2^6배 더 많은 작업이 필요합니다.

![Cumulative difficulty](https://github.com/user-attachments/assets/4fc56fad-464d-42c5-91b2-308505c039f3)

```ts
  const newUnspentTxOuts = ValidateChain(newBlockchain);
  if (
    !!newUnspentTxOuts &&
    getAccumulatedDifficulty(newBlockchain) >
      getAccumulatedDifficulty(getBlockchain())
  ) {
    console.log(
      "Received blockchain is valid. Replacing current blockchain with received blockchain"
    );
    blockchain = newBlockchain;
    setUnspentTxOuts(newUnspentTxOuts);
    updateMempool(unspentTxOuts);
  } else {
    console.log("Received blockchain invalid");
  }
};

const getAccumulatedDifficulty = (aBlockchain: Block[]): number =>
  aBlockchain.reduce((sum, block) => sum + 2 ** block.difficulty, 0);
```

## 다음 챕터

다음 챕터에서는 블록 데이터에 들어갈 Transactions을 구현하겠습니다.
